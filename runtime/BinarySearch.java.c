// This is automatically generated by the Tiger compiler.
// Do NOT modify!

//declaration
struct BinarySearch_vtable BinarySearch_vtable_;
struct BS_vtable BS_vtable_;
// structures
struct BinarySearch
{
  struct BinarySearch_vtable *vptr;
};
struct BS
{
  struct BS_vtable *vptr;
  int * number;
  int size;
};
// vtables structures
struct BinarySearch_vtable
{
};

struct BS_vtable
{
  int (*Start)();
  unsigned char (*Search)();
  int (*Div)();
  unsigned char (*Compare)();
  int (*Print)();
  int (*Init)();
};


// methods
int BS_Start(struct BS * this, int sz)
{
  int aux01;
  int aux02;
  struct BS * Init;
  struct BS * Print;
  struct BS * Search;

  aux01 = (Init=this, Init->vptr->Init(Init, sz));
  aux02 = (Print=this, Print->vptr->Print(Print));
  if ((Search=this, Search->vptr->Search(Search, 8)))
    System_out_println (1);
  else
    System_out_println (0);

  if ((Search=this, Search->vptr->Search(Search, 19)))
    System_out_println (1);
  else
    System_out_println (0);

  if ((Search=this, Search->vptr->Search(Search, 20)))
    System_out_println (1);
  else
    System_out_println (0);

  if ((Search=this, Search->vptr->Search(Search, 21)))
    System_out_println (1);
  else
    System_out_println (0);

  if ((Search=this, Search->vptr->Search(Search, 37)))
    System_out_println (1);
  else
    System_out_println (0);

  if ((Search=this, Search->vptr->Search(Search, 38)))
    System_out_println (1);
  else
    System_out_println (0);

  if ((Search=this, Search->vptr->Search(Search, 39)))
    System_out_println (1);
  else
    System_out_println (0);

  if ((Search=this, Search->vptr->Search(Search, 50)))
    System_out_println (1);
  else
    System_out_println (0);

  return 999;
}
unsigned char BS_Search(struct BS * this, int num)
{
  unsigned char bs01;
  int right;
  int left;
  unsigned char var_cont;
  int medium;
  int aux01;
  int nt;
  struct BS * Div;
  struct BS * Compare;

  aux01 = 0;
  bs01 = 0;
  right = sizeof(this->number)/sizeof(int);
  right = right - 1;
  left = 0;
  var_cont = 1;
  while(  var_cont)
    {
        medium = left + right;
        medium = (Div=this, Div->vptr->Div(Div, medium));
        aux01 = this->number[medium];
        if (num < aux01)
      right = medium - 1;
    else
      left = medium + 1;

        if ((Compare=this, Compare->vptr->Compare(Compare, aux01, num)))
      var_cont = 0;
    else
      var_cont = 1;

        if (right < left)
      var_cont = 0;
    else
      nt = 0;

    }
        if ((Compare=this, Compare->vptr->Compare(Compare, aux01, num)))
      bs01 = 1;
    else
      bs01 = 0;

      return bs01;
}
int BS_Div(struct BS * this, int num)
{
  int count01;
  int count02;
  int aux03;

  count01 = 0;
  count02 = 0;
  aux03 = num - 1;
  while(  count02 < aux03)
    {
        count01 = count01 + 1;
        count02 = count02 + 2;
    }
      return count01;
}
unsigned char BS_Compare(struct BS * this, int num1, int num2)
{
  unsigned char retval;
  int aux02;

  retval = 0;
  aux02 = num2 + 1;
  if (num1 < num2)
    retval = 0;
  else
    if (!num1 < aux02)
      retval = 0;
    else
      retval = 1;


  return retval;
}
int BS_Print(struct BS * this)
{
  int j;

  j = 1;
  while(  j < this->size)
    {
        System_out_println (this->number[j]);
        j = j + 1;
    }
        System_out_println (99999);
      return 0;
}
int BS_Init(struct BS * this, int sz)
{
  int j;
  int k;
  int aux02;
  int aux01;

  this->size = sz;
  this->number = (int *)malloc(sizeof(int)*sz);
  j = 1;
  k = this->size + 1;
  while(  j < this->size)
    {
        aux01 = 2 * j;
        aux02 = k - 3;
        this->number[j] = aux01 + aux02;
        j = j + 1;
        k = k - 1;
    }
      return 0;
}

// vtables
struct BinarySearch_vtable BinarySearch_vtable_ = 
{
};

struct BS_vtable BS_vtable_ = 
{
  BS_Start,
  BS_Search,
  BS_Div,
  BS_Compare,
  BS_Print,
  BS_Init,
};


// main method
int Tiger_main ()
{
  struct BS * Start;
  System_out_println ((Start=((struct BS*)(Tiger_new (&BS_vtable_, sizeof(struct BS)))), Start->vptr->Start(Start, 20)));
}




